/* $Id: wsola.h 2850 2009-08-01 09:20:59Z bennylp $ */
/* 
 * Copyright (C) 2008-2009 Teluu Inc. (http://www.teluu.com)
 * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */
#ifndef __MS_WSOLA_H__
#define __MS_WSOLA_H__

#include <mediastreamer2/mscommon.h>

#ifdef __cplusplus
extern "C"{
#endif

#ifndef pj_assert
#   define pj_assert(expr)   assert(expr)
#endif


#define ASSERT_RETURN(expr,retval)    pj_assert(expr)

#define PI		    3.14159265358979323846	/* pi	    */
#define MS_1_PI		0.318309886183790671538	/* 1/pi	    */

#define HAS_FLOATING_POINT	    1

#define MS_WSOLA_IMP_NULL		    0

/**
* This denotes implementation of WSOLA using fixed or floating point WSOLA
* algorithm. This implementation provides the best quality of the result,
* at the expense of one frame delay and intensive processing power 
* requirement.
*/
#define MS_WSOLA_IMP_WSOLA		    1

/**
* This denotes implementation of WSOLA algorithm with faster waveform 
* similarity calculation. This implementation provides fair quality of 
* the result with the main advantage of low processing power requirement.
*/
#define MS_WSOLA_IMP_WSOLA_LITE	    2

/**
* Specify type of Waveform based Similarity Overlap and Add (WSOLA) backend
* implementation to be used. WSOLA is an algorithm to expand and/or compress 
* audio frames without changing the pitch, and used by the delaybuf and as PLC
* backend algorithm.
*
* Default is MS_WSOLA_IMP_WSOLA
*/
#ifndef MS_WSOLA_IMP
#   define MS_WSOLA_IMP MS_WSOLA_IMP_WSOLA
#endif

#ifndef UNUSED_ARG
#define UNUSED_ARG(x)
#endif

#define EINVAL 70004
#define EINVALIDOP 70013
#define ETOOSMALL 70005

#ifndef MS_WSOLA_PLC_NO_FADING
#   define MS_WSOLA_PLC_NO_FADING	    0
#endif

#ifndef MS_WSOLA_MAX_EXPAND_MSEC
#   define MS_WSOLA_MAX_EXPAND_MSEC    80
#endif

#ifndef MS_WSOLA_TEMPLATE_LENGTH_MSEC
#   define MS_WSOLA_TEMPLATE_LENGTH_MSEC	5
#endif

#ifndef MS_WSOLA_DELAY_MSEC
#   define MS_WSOLA_DELAY_MSEC	    5
#endif


/**
 * Opaque declaration for WSOLA structure.
 */
typedef struct ms_wsola ms_wsola;

/**
 * WSOLA options, can be combined with bitmask operation.
 */
enum ms_wsola_option
{
    /**
     * Disable Hanning window to conserve memory.
     */
    MS_WSOLA_NO_HANNING	= 1,

    /**
     * Specify that the WSOLA will not be used for PLC.
     */
    MS_WSOLA_NO_PLC = 2,

    /**
     * Specify that the WSOLA will not be used to discard frames in
     * non-contiguous buffer.
     */
    MS_WSOLA_NO_DISCARD = 4,

    /**
     * Disable fade-in and fade-out feature in the transition between
     * actual and synthetic frames in WSOLA. With fade feature enabled, 
     * WSOLA will only generate a limited number of synthetic frames 
     * (configurable with #ms_wsola_set_max_expand()), fading out 
     * the volume on every more samples it generates, and when it reaches
     * the limit it will only generate silence.
     */
    MS_WSOLA_NO_FADING = 8
};



/**
 * Create and initialize WSOLA.
 *
 * @param pool		    Pool to allocate memory for WSOLA.
 * @param clock_rate	    Sampling rate of audio playback.
 * @param samples_per_frame Number of samples per frame.
 * @param channel_count	    Number of channels.
 * @param options	    Option flags, bitmask combination of
 *			    #ms_wsola_option.
 * @param p_wsola	    Pointer to receive WSOLA structure.
 *
 * @return		    SUCCESS or the appropriate error code.
 */
int ms_wsola_create(unsigned clock_rate,
					  unsigned samples_per_frame,
					  unsigned channel_count,
					  unsigned options,
					  ms_wsola **p_wsola);


/**
 * Specify maximum number of continuous synthetic frames that can be
 * generated by WSOLA, in milliseconds. This option will only take
 * effect if fading is not disabled via the option when the WSOLA
 * session was created. Default value is MS_WSOLA_MAX_EXPAND_MSEC
 * (see also the documentation of MS_WSOLA_MAX_EXPAND_MSEC for
 * more information).
 *
 * @param wsola	    The WSOLA session
 * @param msec	    The duration.
 *
 * @return	    SUCCESS normally.
 */
int ms_wsola_set_max_expand(ms_wsola *wsola,
						  unsigned msec);


/**
 * Destroy WSOLA.
 *
 * @param wsola	    WSOLA session.
 *
 * @return	    SUCCESS normally.
 */
int ms_wsola_destroy(ms_wsola *wsola);


/**
 * Reset the buffer contents of WSOLA.
 *
 * @param wsola	    WSOLA session.
 * @param options   Reset options, must be zero for now.
 *
 * @return	    SUCCESS normally.
 */
int ms_wsola_reset(ms_wsola *wsola,
					 unsigned options);


/**
 * Give one good frame to WSOLA to be kept as reference. Application
 * must continuously give WSOLA good frames to keep its session up to
 * date with current playback. Depending on the WSOLA implementation,
 * this function may modify the content of the frame.
 *
 * @param wsola	    WSOLA session.
 * @param frm	    The frame, which length must match the samples per
 *		    frame setting of the WSOLA session.
 * @param prev_lost If application previously generated a synthetic
 *		    frame with #ms_wsola_generate() before calling
 *		    this function, specify whether that was because of
 *		    packet lost. If so, set this parameter to TRUE
 *		    to make WSOLA interpolate this frame with its buffer.
 *		    Otherwise if this value is FALSE, WSOLA will
 *		    just append this frame to the end of its buffer.
 *
 * @return	    SUCCESS normally.
 */
int ms_wsola_save(ms_wsola *wsola, 
					int16_t frm[], 
					bool_t prev_lost);

/**
 * Generate one synthetic frame from WSOLA.
 *
 * @param wsola	    WSOLA session.
 * @param frm	    Buffer to receive the frame.
 *
 * @return	    SUCCESS normally.
 */
int ms_wsola_generate(ms_wsola *wsola, 
					    int16_t frm[]);


/**
 * Compress or compact the specified buffer by removing some audio samples
 * from the buffer, without altering the pitch. For this function to work, 
 * total length of the buffer must be more than twice \a erase_cnt.
 * 
 * @param wsola	    WSOLA session.
 * @param buf1	    Pointer to buffer. 
 * @param buf1_cnt  Number of samples in the buffer.
 * @param buf2	    Pointer to second buffer, if the buffer is not
 *		    contiguous. Otherwise this parameter must be NULL.
 * @param buf2_cnt  Number of samples in the second buffer, if the buffer
 *		    is not contiguous. Otherwise this parameter should be
 *		    zero.
 * @param erase_cnt On input, specify the number of samples to be erased.
 *		    This function may erase more or less than the requested 
 *		    number, and the actual number of samples erased will be 
 *		    given on this argument upon returning from the function.
 *
 * @return	    SUCCESS if some samples have been erased, ETOOSMALL
 *		    if buffer is too small to be reduced, EINVAL if any
 *		    of the parameters are not valid.
 */
int ms_wsola_discard(ms_wsola *wsola, 
					   int16_t buf1[],
					   unsigned buf1_cnt, 
					   int16_t buf2[],
					   unsigned buf2_cnt,
					   unsigned *erase_cnt);



#ifdef __cplusplus
}
#endif

#endif	/* __MS_WSOLA_H__ */

