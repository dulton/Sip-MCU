<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libtheora: theora.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>theora.h File Reference</h1>The libtheora C API. <a href="#_details">More...</a>
<p>
<code>#include &lt;ogg/ogg.h&gt;</code><br>

<p>
<a href="theora_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyuv__buffer.html">yuv_buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A YUV buffer for passing uncompressed frames to and from the codec.  <a href="structyuv__buffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__info.html">theora_info</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Theora bitstream info.  <a href="structtheora__info.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__state.html">theora_state</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Codec internal state and context.  <a href="structtheora__state.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__comment.html">theora_comment</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comment header metadata.  <a href="structtheora__comment.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95aff598c4af451822e7e836b3886cbf"></a><!-- doxytag: member="theora.h::OC_FAULT" ref="95aff598c4af451822e7e836b3886cbf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#95aff598c4af451822e7e836b3886cbf">OC_FAULT</a>&nbsp;&nbsp;&nbsp;-1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General failure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="06a281a54a00da88abf1a3b29ec11e4a"></a><!-- doxytag: member="theora.h::OC_EINVAL" ref="06a281a54a00da88abf1a3b29ec11e4a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#06a281a54a00da88abf1a3b29ec11e4a">OC_EINVAL</a>&nbsp;&nbsp;&nbsp;-10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Library encountered invalid internal data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b2bc670dc664c72ea6fcbaf9deda3476"></a><!-- doxytag: member="theora.h::OC_DISABLED" ref="b2bc670dc664c72ea6fcbaf9deda3476" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#b2bc670dc664c72ea6fcbaf9deda3476">OC_DISABLED</a>&nbsp;&nbsp;&nbsp;-11</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requested action is disabled. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d583a6c9a30e48ec7d4ea937f769614"></a><!-- doxytag: member="theora.h::OC_BADHEADER" ref="9d583a6c9a30e48ec7d4ea937f769614" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#9d583a6c9a30e48ec7d4ea937f769614">OC_BADHEADER</a>&nbsp;&nbsp;&nbsp;-20</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Header packet was corrupt/invalid. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed82978e76177264a6b8fc3278697c33"></a><!-- doxytag: member="theora.h::OC_NOTFORMAT" ref="ed82978e76177264a6b8fc3278697c33" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#ed82978e76177264a6b8fc3278697c33">OC_NOTFORMAT</a>&nbsp;&nbsp;&nbsp;-21</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packet is not a theora packet. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1398927f9660a187ae02d93022795ae8"></a><!-- doxytag: member="theora.h::OC_VERSION" ref="1398927f9660a187ae02d93022795ae8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#1398927f9660a187ae02d93022795ae8">OC_VERSION</a>&nbsp;&nbsp;&nbsp;-22</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitstream version is not handled. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d58ee606f97079e94c30549584fd7c8"></a><!-- doxytag: member="theora.h::OC_IMPL" ref="5d58ee606f97079e94c30549584fd7c8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#5d58ee606f97079e94c30549584fd7c8">OC_IMPL</a>&nbsp;&nbsp;&nbsp;-23</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Feature or action not implemented. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36091b71b428f52454e363463ef6e445"></a><!-- doxytag: member="theora.h::OC_BADPACKET" ref="36091b71b428f52454e363463ef6e445" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#36091b71b428f52454e363463ef6e445">OC_BADPACKET</a>&nbsp;&nbsp;&nbsp;-24</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packet is corrupt. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="efea777076ff2a9004b418415edba208"></a><!-- doxytag: member="theora.h::OC_NEWPACKET" ref="efea777076ff2a9004b418415edba208" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#efea777076ff2a9004b418415edba208">OC_NEWPACKET</a>&nbsp;&nbsp;&nbsp;-25</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packet is an (ignorable) unhandled extension. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4e82ad9e3a51af2f9659f2eb353170e"></a><!-- doxytag: member="theora.h::OC_DUPFRAME" ref="a4e82ad9e3a51af2f9659f2eb353170e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a4e82ad9e3a51af2f9659f2eb353170e">OC_DUPFRAME</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packet is a dropped frame. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#fdb3ecc6cbb1a6c346281db5c972d52d">theora_colorspace</a> { <a class="el" href="theora_8h.html#fdb3ecc6cbb1a6c346281db5c972d52d98594a87da35091a8baa4643bd8904ef">OC_CS_UNSPECIFIED</a>, 
<a class="el" href="theora_8h.html#fdb3ecc6cbb1a6c346281db5c972d52d91b8497a22276b56b62cbec714c6365f">OC_CS_ITU_REC_470M</a>, 
<a class="el" href="theora_8h.html#fdb3ecc6cbb1a6c346281db5c972d52d3d957a2abfb9f9b11912eddb564365d3">OC_CS_ITU_REC_470BG</a>, 
<a class="el" href="theora_8h.html#fdb3ecc6cbb1a6c346281db5c972d52d171c884c1c919c2c264f8bf6224d758f">OC_CS_NSPACES</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Colorspace.  <a href="theora_8h.html#fdb3ecc6cbb1a6c346281db5c972d52d">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#e6d5fa4a952719a002d8df5ba19fd7d3">theora_pixelformat</a> { <a class="el" href="theora_8h.html#e6d5fa4a952719a002d8df5ba19fd7d3ba38f832e52748c1df744683c15fe05b">OC_PF_420</a>, 
<a class="el" href="theora_8h.html#e6d5fa4a952719a002d8df5ba19fd7d317351a1b9c53cd886ad34c3b1d3bd7b3">OC_PF_RSVD</a>, 
<a class="el" href="theora_8h.html#e6d5fa4a952719a002d8df5ba19fd7d3c841320c974a9704f146d52d08f31cb0">OC_PF_422</a>, 
<a class="el" href="theora_8h.html#e6d5fa4a952719a002d8df5ba19fd7d3a2c8a52c7c2e20fac7b0182579e89144">OC_PF_444</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Chroma subsampling.  <a href="theora_8h.html#e6d5fa4a952719a002d8df5ba19fd7d3">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#7682deb3e6612db562f54ea66b95584b">theora_version_string</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a human-readable string to identify the encoder vendor and version.  <a href="#7682deb3e6612db562f54ea66b95584b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ogg_uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#d9cec696a9c830e9b3cb1bf4e372b23d">theora_version_number</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a 32-bit version number.  <a href="#d9cec696a9c830e9b3cb1bf4e372b23d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#9544a8feccd8a25e6336a57eac2c411e">theora_encode_init</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structtheora__info.html">theora_info</a> *ti)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the theora encoder.  <a href="#9544a8feccd8a25e6336a57eac2c411e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#21afcb28b49f5c775a4dbe6ab1d8b00e">theora_encode_YUVin</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, <a class="el" href="structyuv__buffer.html">yuv_buffer</a> *yuv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit a YUV buffer to the theora encoder.  <a href="#21afcb28b49f5c775a4dbe6ab1d8b00e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#bd4b6f1eb80929ea318fbaa1d5d7fba3">theora_encode_packetout</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, int last_p, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request the next packet of encoded video.  <a href="#bd4b6f1eb80929ea318fbaa1d5d7fba3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#4f9e6ef696ec209d14749177edde69f4">theora_encode_header</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a packet containing the initial header.  <a href="#4f9e6ef696ec209d14749177edde69f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#db11c4000d2a049167ea1d0a6aa12194">theora_encode_comment</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a comment header packet from provided metadata.  <a href="#db11c4000d2a049167ea1d0a6aa12194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#74fcaad3b21a9bfa643f0627ecba96d7">theora_encode_tables</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a packet containing the codebook tables for the stream.  <a href="#74fcaad3b21a9bfa643f0627ecba96d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#41a60c67649c41ae88278d777f89ee3f">theora_decode_header</a> (<a class="el" href="structtheora__info.html">theora_info</a> *ci, <a class="el" href="structtheora__comment.html">theora_comment</a> *cc, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode an Ogg packet, with the expectation that the packet contains an initial header, comment data or codebook tables.  <a href="#41a60c67649c41ae88278d777f89ee3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a9f81159ae039353cac6076a59fba871">theora_decode_init</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a <a class="el" href="structtheora__state.html">theora_state</a> handle for decoding.  <a href="#a9f81159ae039353cac6076a59fba871"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a67cbe3cc458aad10904c0cc78044fc5">theora_decode_packetin</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input a packet containing encoded data into the theora decoder.  <a href="#a67cbe3cc458aad10904c0cc78044fc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#38049cd76f6f1d30906344dcc747782c">theora_decode_YUVout</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structyuv__buffer.html">yuv_buffer</a> *yuv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output the next available frame of decoded YUV data.  <a href="#38049cd76f6f1d30906344dcc747782c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#b75731ff4e6a113430715dee160c1626">theora_packet_isheader</a> (ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report whether a theora packet is a header or not This function does no verification beyond checking the header flag bit so it should not be used for bitstream identification; use <a class="el" href="theora_8h.html#41a60c67649c41ae88278d777f89ee3f">theora_decode_header()</a> for that.  <a href="#b75731ff4e6a113430715dee160c1626"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#88a636ebe2e390aa0ca6bb547912814f">theora_packet_iskeyframe</a> (ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report whether a theora packet is a keyframe or not.  <a href="#88a636ebe2e390aa0ca6bb547912814f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#3fd68eba5a134ac84d4db08dd8126991">theora_granule_shift</a> (<a class="el" href="structtheora__info.html">theora_info</a> *ti)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report the granulepos shift radix.  <a href="#3fd68eba5a134ac84d4db08dd8126991"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ogg_int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#072d4900733c1d0798b868dafb50847c">theora_granule_frame</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, ogg_int64_t granulepos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a granulepos to an absolute frame number.  <a href="#072d4900733c1d0798b868dafb50847c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#56a89dbe9051fe6a3b7b31a6812df77d">theora_granule_time</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, ogg_int64_t granulepos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a granulepos to absolute time in seconds.  <a href="#56a89dbe9051fe6a3b7b31a6812df77d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#f0f9fbb7e7bcce3c536e0b46d300c71e">theora_info_init</a> (<a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a <a class="el" href="structtheora__info.html">theora_info</a> structure.  <a href="#f0f9fbb7e7bcce3c536e0b46d300c71e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#c72b3f8c404d658d1e675e39a75b1931">theora_info_clear</a> (<a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear a <a class="el" href="structtheora__info.html">theora_info</a> structure.  <a href="#c72b3f8c404d658d1e675e39a75b1931"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#c3d872f1cbe57918661471cf41fe2949">theora_clear</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all internal data associated with a <a class="el" href="structtheora__state.html">theora_state</a> handle.  <a href="#c3d872f1cbe57918661471cf41fe2949"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#531adee5230be7d45af1dede0e82c79a">theora_comment_init</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize an allocated <a class="el" href="structtheora__comment.html">theora_comment</a> structure.  <a href="#531adee5230be7d45af1dede0e82c79a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#795da8fab8fe137dea276d6bf20bf5f2">theora_comment_add</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a comment to an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure.  <a href="#795da8fab8fe137dea276d6bf20bf5f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#adc406fcdc1d2192ae2a9adfb3bd4e6f">theora_comment_add_tag</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag, char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a comment to an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure.  <a href="#adc406fcdc1d2192ae2a9adfb3bd4e6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#0071768c54009941f50d7c738a33340d">theora_comment_query</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up a comment value by tag.  <a href="#0071768c54009941f50d7c738a33340d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#d0ee4a15b96518d5d8ab38df814c0b27">theora_comment_query_count</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up the number of instances of a tag.  <a href="#d0ee4a15b96518d5d8ab38df814c0b27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#7cabfa586d5e0ecae1dedd7c05d6a1fe">theora_comment_clear</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear an allocated <a class="el" href="structtheora__comment.html">theora_comment</a> struct so that it can be freed.  <a href="#7cabfa586d5e0ecae1dedd7c05d6a1fe"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The libtheora C API. 
<p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="fdb3ecc6cbb1a6c346281db5c972d52d"></a><!-- doxytag: member="theora.h::theora_colorspace" ref="fdb3ecc6cbb1a6c346281db5c972d52d" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="theora_8h.html#fdb3ecc6cbb1a6c346281db5c972d52d">theora_colorspace</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A Colorspace. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="fdb3ecc6cbb1a6c346281db5c972d52d98594a87da35091a8baa4643bd8904ef"></a><!-- doxytag: member="OC_CS_UNSPECIFIED" ref="fdb3ecc6cbb1a6c346281db5c972d52d98594a87da35091a8baa4643bd8904ef" args="" -->OC_CS_UNSPECIFIED</em>&nbsp;</td><td>
The colorspace is unknown or unspecified. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdb3ecc6cbb1a6c346281db5c972d52d91b8497a22276b56b62cbec714c6365f"></a><!-- doxytag: member="OC_CS_ITU_REC_470M" ref="fdb3ecc6cbb1a6c346281db5c972d52d91b8497a22276b56b62cbec714c6365f" args="" -->OC_CS_ITU_REC_470M</em>&nbsp;</td><td>
This is the best option for 'NTSC' content. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdb3ecc6cbb1a6c346281db5c972d52d3d957a2abfb9f9b11912eddb564365d3"></a><!-- doxytag: member="OC_CS_ITU_REC_470BG" ref="fdb3ecc6cbb1a6c346281db5c972d52d3d957a2abfb9f9b11912eddb564365d3" args="" -->OC_CS_ITU_REC_470BG</em>&nbsp;</td><td>
This is the best option for 'PAL' content. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdb3ecc6cbb1a6c346281db5c972d52d171c884c1c919c2c264f8bf6224d758f"></a><!-- doxytag: member="OC_CS_NSPACES" ref="fdb3ecc6cbb1a6c346281db5c972d52d171c884c1c919c2c264f8bf6224d758f" args="" -->OC_CS_NSPACES</em>&nbsp;</td><td>
This marks the end of the defined colorspaces. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e6d5fa4a952719a002d8df5ba19fd7d3"></a><!-- doxytag: member="theora.h::theora_pixelformat" ref="e6d5fa4a952719a002d8df5ba19fd7d3" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="theora_8h.html#e6d5fa4a952719a002d8df5ba19fd7d3">theora_pixelformat</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A Chroma subsampling. 
<p>
These enumerate the available chroma subsampling options supported by the theora format. See Section 4.4 of the specification for exact definitions. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="e6d5fa4a952719a002d8df5ba19fd7d3ba38f832e52748c1df744683c15fe05b"></a><!-- doxytag: member="OC_PF_420" ref="e6d5fa4a952719a002d8df5ba19fd7d3ba38f832e52748c1df744683c15fe05b" args="" -->OC_PF_420</em>&nbsp;</td><td>
Chroma subsampling by 2 in each direction (4:2:0). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e6d5fa4a952719a002d8df5ba19fd7d317351a1b9c53cd886ad34c3b1d3bd7b3"></a><!-- doxytag: member="OC_PF_RSVD" ref="e6d5fa4a952719a002d8df5ba19fd7d317351a1b9c53cd886ad34c3b1d3bd7b3" args="" -->OC_PF_RSVD</em>&nbsp;</td><td>
Reserved value. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e6d5fa4a952719a002d8df5ba19fd7d3c841320c974a9704f146d52d08f31cb0"></a><!-- doxytag: member="OC_PF_422" ref="e6d5fa4a952719a002d8df5ba19fd7d3c841320c974a9704f146d52d08f31cb0" args="" -->OC_PF_422</em>&nbsp;</td><td>
Horizonatal chroma subsampling by 2 (4:2:2). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e6d5fa4a952719a002d8df5ba19fd7d3a2c8a52c7c2e20fac7b0182579e89144"></a><!-- doxytag: member="OC_PF_444" ref="e6d5fa4a952719a002d8df5ba19fd7d3a2c8a52c7c2e20fac7b0182579e89144" args="" -->OC_PF_444</em>&nbsp;</td><td>
No chroma subsampling at all (4:4:4). </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c3d872f1cbe57918661471cf41fe2949"></a><!-- doxytag: member="theora.h::theora_clear" ref="c3d872f1cbe57918661471cf41fe2949" args="(theora_state *t)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>t</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free all internal data associated with a <a class="el" href="structtheora__state.html">theora_state</a> handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="795da8fab8fe137dea276d6bf20bf5f2"></a><!-- doxytag: member="theora.h::theora_comment_add" ref="795da8fab8fe137dea276d6bf20bf5f2" args="(theora_comment *tc, char *comment)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_comment_add           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>comment</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a comment to an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>A previously initialized theora comment structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comment</em>&nbsp;</td><td>A null-terminated string encoding the comment in the form "TAG=the value"</td></tr>
  </table>
</dl>
Neither <a class="el" href="theora_8h.html#795da8fab8fe137dea276d6bf20bf5f2">theora_comment_add()</a> nor <a class="el" href="theora_8h.html#adc406fcdc1d2192ae2a9adfb3bd4e6f">theora_comment_add_tag()</a> support comments containing null values, although the bitstream format supports this. To add such comments you will need to manipulate the <a class="el" href="structtheora__comment.html">theora_comment</a> structure directly.     </td>
  </tr>
</table>
<a class="anchor" name="adc406fcdc1d2192ae2a9adfb3bd4e6f"></a><!-- doxytag: member="theora.h::theora_comment_add_tag" ref="adc406fcdc1d2192ae2a9adfb3bd4e6f" args="(theora_comment *tc, char *tag, char *value)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_comment_add_tag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a comment to an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>A previously initialized theora comment structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>A null-terminated string containing the tag associated with the comment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The corresponding value as a null-terminated string</td></tr>
  </table>
</dl>
Neither <a class="el" href="theora_8h.html#795da8fab8fe137dea276d6bf20bf5f2">theora_comment_add()</a> nor <a class="el" href="theora_8h.html#adc406fcdc1d2192ae2a9adfb3bd4e6f">theora_comment_add_tag()</a> support comments containing null values, although the bitstream format supports this. To add such comments you will need to manipulate the <a class="el" href="structtheora__comment.html">theora_comment</a> structure directly.     </td>
  </tr>
</table>
<a class="anchor" name="7cabfa586d5e0ecae1dedd7c05d6a1fe"></a><!-- doxytag: member="theora.h::theora_comment_clear" ref="7cabfa586d5e0ecae1dedd7c05d6a1fe" args="(theora_comment *tc)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_comment_clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear an allocated <a class="el" href="structtheora__comment.html">theora_comment</a> struct so that it can be freed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>An allocated <a class="el" href="structtheora__comment.html">theora_comment</a> structure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="531adee5230be7d45af1dede0e82c79a"></a><!-- doxytag: member="theora.h::theora_comment_init" ref="531adee5230be7d45af1dede0e82c79a" args="(theora_comment *tc)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_comment_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize an allocated <a class="el" href="structtheora__comment.html">theora_comment</a> structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>An allocated <a class="el" href="structtheora__comment.html">theora_comment</a> structure </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0071768c54009941f50d7c738a33340d"></a><!-- doxytag: member="theora.h::theora_comment_query" ref="0071768c54009941f50d7c738a33340d" args="(theora_comment *tc, char *tag, int count)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* theora_comment_query           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Look up a comment value by tag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>Tn initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>The tag to look up </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The instance of the tag. The same tag can appear multiple times, each with a distinct and ordered value, so an index is required to retrieve them all. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the queried tag's value </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>No matching tag is found</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Use <a class="el" href="theora_8h.html#d0ee4a15b96518d5d8ab38df814c0b27">theora_comment_query_count()</a> to get the legal range for the count parameter. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d0ee4a15b96518d5d8ab38df814c0b27"></a><!-- doxytag: member="theora.h::theora_comment_query_count" ref="d0ee4a15b96518d5d8ab38df814c0b27" args="(theora_comment *tc, char *tag)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_comment_query_count           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tag</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Look up the number of instances of a tag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>An initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>The tag to look up </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number on instances of a particular tag.</dd></dl>
Call this first when querying for a specific tag and then interate over the number of instances with separate calls to <a class="el" href="theora_8h.html#0071768c54009941f50d7c738a33340d">theora_comment_query()</a> to retrieve all instances in order.     </td>
  </tr>
</table>
<a class="anchor" name="41a60c67649c41ae88278d777f89ee3f"></a><!-- doxytag: member="theora.h::theora_decode_header" ref="41a60c67649c41ae88278d777f89ee3f" args="(theora_info *ci, theora_comment *cc, ogg_packet *op)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_decode_header           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ci</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>cc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decode an Ogg packet, with the expectation that the packet contains an initial header, comment data or codebook tables. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ci</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> structure to fill. This must have been previously initialized with <a class="el" href="theora_8h.html#f0f9fbb7e7bcce3c536e0b46d300c71e">theora_info_init()</a>. If <em>op</em> contains an initial header, <a class="el" href="theora_8h.html#41a60c67649c41ae88278d777f89ee3f">theora_decode_header()</a> will fill <em>ci</em> with the parsed header values. If <em>op</em> contains codebook tables, <a class="el" href="theora_8h.html#41a60c67649c41ae88278d777f89ee3f">theora_decode_header()</a> will parse these and attach an internal representation to <em>ci-&gt;codec_setup</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cc</em>&nbsp;</td><td>A <a class="el" href="structtheora__comment.html">theora_comment</a> structure to fill. If <em>op</em> contains comment data, <a class="el" href="theora_8h.html#41a60c67649c41ae88278d777f89ee3f">theora_decode_header()</a> will fill <em>cc</em> with the parsed comments. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure which you expect contains an initial header, comment data or codebook tables.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OC_BADHEADER</em>&nbsp;</td><td><em>op</em> is NULL; OR the first byte of <em>op-&gt;packet</em> has the signature of an initial packet, but op is not a b_o_s packet; OR this packet has the signature of an initial header packet, but an initial header packet has already been seen; OR this packet has the signature of a comment packet, but the initial header has not yet been seen; OR this packet has the signature of a comment packet, but contains invalid data; OR this packet has the signature of codebook tables, but the initial header or comments have not yet been seen; OR this packet has the signature of codebook tables, but contains invalid data; OR the stream being decoded has a compatible version but this packet does not have the signature of a theora initial header, comments, or codebook packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OC_VERSION</em>&nbsp;</td><td>The packet data of <em>op</em> is an initial header with a version which is incompatible with this version of libtheora. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OC_NEWPACKET</em>&nbsp;</td><td>the stream being decoded has an incompatible (future) version and contains an unknown signature. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The normal usage is that <a class="el" href="theora_8h.html#41a60c67649c41ae88278d777f89ee3f">theora_decode_header()</a> be called on the first three packets of a theora logical bitstream in succession. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9f81159ae039353cac6076a59fba871"></a><!-- doxytag: member="theora.h::theora_decode_init" ref="a9f81159ae039353cac6076a59fba871" args="(theora_state *th, theora_info *c)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_decode_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>c</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a <a class="el" href="structtheora__state.html">theora_state</a> handle for decoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>The <a class="el" href="structtheora__state.html">theora_state</a> handle to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> struct filled with the desired decoding parameters. This is of course usually obtained from a previous call to <a class="el" href="theora_8h.html#41a60c67649c41ae88278d777f89ee3f">theora_decode_header()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a67cbe3cc458aad10904c0cc78044fc5"></a><!-- doxytag: member="theora.h::theora_decode_packetin" ref="a67cbe3cc458aad10904c0cc78044fc5" args="(theora_state *th, ogg_packet *op)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_decode_packetin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Input a packet containing encoded data into the theora decoder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for decoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet containing encoded theora data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OC_BADPACKET</em>&nbsp;</td><td><em>op</em> does not contain encoded video data </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="38049cd76f6f1d30906344dcc747782c"></a><!-- doxytag: member="theora.h::theora_decode_YUVout" ref="38049cd76f6f1d30906344dcc747782c" args="(theora_state *th, yuv_buffer *yuv)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_decode_YUVout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structyuv__buffer.html">yuv_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>yuv</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Output the next available frame of decoded YUV data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for decoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yuv</em>&nbsp;</td><td>A <a class="el" href="structyuv__buffer.html">yuv_buffer</a> in which libtheora should place the decoded data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="db11c4000d2a049167ea1d0a6aa12194"></a><!-- doxytag: member="theora.h::theora_encode_comment" ref="db11c4000d2a049167ea1d0a6aa12194" args="(theora_comment *tc, ogg_packet *op)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_comment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request a comment header packet from provided metadata. 
<p>
A pointer to the comment data is placed in a user-provided ogg_packet structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>A <a class="el" href="structtheora__comment.html">theora_comment</a> structure filled with the desired metadata </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure to fill. libtheora will set all elements of this structure, including a pointer to the encoded comment data. The memory for the comment data is owned by libtheora. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4f9e6ef696ec209d14749177edde69f4"></a><!-- doxytag: member="theora.h::theora_encode_header" ref="4f9e6ef696ec209d14749177edde69f4" args="(theora_state *t, ogg_packet *op)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_header           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request a packet containing the initial header. 
<p>
A pointer to the header data is placed in a user-provided ogg_packet structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure to fill. libtheora will set all elements of this structure, including a pointer to the header data. The memory for the header data is owned by libtheora. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9544a8feccd8a25e6336a57eac2c411e"></a><!-- doxytag: member="theora.h::theora_encode_init" ref="9544a8feccd8a25e6336a57eac2c411e" args="(theora_state *th, theora_info *ti)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ti</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the theora encoder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>The <a class="el" href="structtheora__state.html">theora_state</a> handle to initialize for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> struct filled with the desired encoding parameters. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bd4b6f1eb80929ea318fbaa1d5d7fba3"></a><!-- doxytag: member="theora.h::theora_encode_packetout" ref="bd4b6f1eb80929ea318fbaa1d5d7fba3" args="(theora_state *t, int last_p, ogg_packet *op)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_packetout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>last_p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request the next packet of encoded video. 
<p>
The encoded data is placed in a user-provided ogg_packet structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last_p</em>&nbsp;</td><td>whether this is the last packet the encoder should produce. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure to fill. libtheora will set all elements of this structure, including a pointer to encoded data. The memory for the encoded data is owned by libtheora. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>No internal storage exists OR no packet is ready </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>The encoding process has completed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="74fcaad3b21a9bfa643f0627ecba96d7"></a><!-- doxytag: member="theora.h::theora_encode_tables" ref="74fcaad3b21a9bfa643f0627ecba96d7" args="(theora_state *t, ogg_packet *op)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_tables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request a packet containing the codebook tables for the stream. 
<p>
A pointer to the codebook data is placed in a user-provided ogg_packet structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure to fill. libtheora will set all elements of this structure, including a pointer to the codebook data. The memory for the header data is owned by libtheora. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="21afcb28b49f5c775a4dbe6ab1d8b00e"></a><!-- doxytag: member="theora.h::theora_encode_YUVin" ref="21afcb28b49f5c775a4dbe6ab1d8b00e" args="(theora_state *t, yuv_buffer *yuv)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_YUVin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structyuv__buffer.html">yuv_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>yuv</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Submit a YUV buffer to the theora encoder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yuv</em>&nbsp;</td><td>A buffer of YUV data to encode. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OC_EINVAL</em>&nbsp;</td><td>Encoder is not ready, or is finished. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>The size of the given frame differs from those previously input </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="072d4900733c1d0798b868dafb50847c"></a><!-- doxytag: member="theora.h::theora_granule_frame" ref="072d4900733c1d0798b868dafb50847c" args="(theora_state *th, ogg_int64_t granulepos)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ogg_int64_t theora_granule_frame           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_int64_t&nbsp;</td>
          <td class="mdname" nowrap> <em>granulepos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert a granulepos to an absolute frame number. 
<p>
The granulepos is interpreted in the context of a given <a class="el" href="structtheora__state.html">theora_state</a> handle.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>A previously initialized <a class="el" href="structtheora__state.html">theora_state</a> handle (encode or decode) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>granulepos</em>&nbsp;</td><td>The granulepos to convert. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The frame number corresponding to <em>granulepos</em>. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>The given granulepos is undefined (i.e. negative)</td></tr>
  </table>
</dl>
Thus function was added in the 1.0alpha4 release.     </td>
  </tr>
</table>
<a class="anchor" name="3fd68eba5a134ac84d4db08dd8126991"></a><!-- doxytag: member="theora.h::theora_granule_shift" ref="3fd68eba5a134ac84d4db08dd8126991" args="(theora_info *ti)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_granule_shift           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ti</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Report the granulepos shift radix. 
<p>
When embedded in Ogg, Theora uses a two-part granulepos, splitting the 64-bit field into two pieces. The more-significant section represents the frame count at the last keyframe, and the less-significant section represents the count of frames since the last keyframe. In this way the overall field is still non-decreasing with time, but usefully encodes a pointer to the last keyframe, which is necessary for correctly restarting decode after a seek.<p>
This function reports the number of bits used to represent the distance to the last keyframe, and thus how the granulepos field must be shifted or masked to obtain the two parts.<p>
Since libtheora returns compressed data in an ogg_packet structure, this may be generally useful even if the Theora packets are not being used in an Ogg container.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>A previously initialized <a class="el" href="structtheora__info.html">theora_info</a> struct </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The bit shift dividing the two granulepos fields</dd></dl>
This function was added in the 1.0alpha5 release.     </td>
  </tr>
</table>
<a class="anchor" name="56a89dbe9051fe6a3b7b31a6812df77d"></a><!-- doxytag: member="theora.h::theora_granule_time" ref="56a89dbe9051fe6a3b7b31a6812df77d" args="(theora_state *th, ogg_int64_t granulepos)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double theora_granule_time           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_int64_t&nbsp;</td>
          <td class="mdname" nowrap> <em>granulepos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert a granulepos to absolute time in seconds. 
<p>
The granulepos is interpreted in the context of a given <a class="el" href="structtheora__state.html">theora_state</a> handle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>A previously initialized <a class="el" href="structtheora__state.html">theora_state</a> handle (encode or decode) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>granulepos</em>&nbsp;</td><td>The granulepos to convert. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The absolute time in seconds corresponding to <em>granulepos</em>. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1.</em>&nbsp;</td><td>The given granulepos is undefined (i.e. negative), or </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1.</em>&nbsp;</td><td>The function has been disabled because floating point support is not available. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c72b3f8c404d658d1e675e39a75b1931"></a><!-- doxytag: member="theora.h::theora_info_clear" ref="c72b3f8c404d658d1e675e39a75b1931" args="(theora_info *c)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_info_clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>c</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear a <a class="el" href="structtheora__info.html">theora_info</a> structure. 
<p>
All values within the given <a class="el" href="structtheora__info.html">theora_info</a> structure are cleared, and associated internal codec setup data is freed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> struct to initialize. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f0f9fbb7e7bcce3c536e0b46d300c71e"></a><!-- doxytag: member="theora.h::theora_info_init" ref="f0f9fbb7e7bcce3c536e0b46d300c71e" args="(theora_info *c)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_info_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>c</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a <a class="el" href="structtheora__info.html">theora_info</a> structure. 
<p>
All values within the given <a class="el" href="structtheora__info.html">theora_info</a> structure are initialized, and space is allocated within libtheora for internal codec setup data. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> struct to initialize. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b75731ff4e6a113430715dee160c1626"></a><!-- doxytag: member="theora.h::theora_packet_isheader" ref="b75731ff4e6a113430715dee160c1626" args="(ogg_packet *op)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_packet_isheader           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ogg_packet *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>op</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Report whether a theora packet is a header or not This function does no verification beyond checking the header flag bit so it should not be used for bitstream identification; use <a class="el" href="theora_8h.html#41a60c67649c41ae88278d777f89ee3f">theora_decode_header()</a> for that. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet containing encoded theora data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>The packet is a header packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>The packet is not a header packet (and so contains frame data)</td></tr>
  </table>
</dl>
Thus function was added in the 1.0alpha4 release.     </td>
  </tr>
</table>
<a class="anchor" name="88a636ebe2e390aa0ca6bb547912814f"></a><!-- doxytag: member="theora.h::theora_packet_iskeyframe" ref="88a636ebe2e390aa0ca6bb547912814f" args="(ogg_packet *op)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_packet_iskeyframe           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ogg_packet *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>op</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Report whether a theora packet is a keyframe or not. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet containing encoded theora data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>The packet contains a keyframe image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>The packet is contains an interframe delta </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>The packet is not an image data packet at all</td></tr>
  </table>
</dl>
Thus function was added in the 1.0alpha4 release.     </td>
  </tr>
</table>
<a class="anchor" name="d9cec696a9c830e9b3cb1bf4e372b23d"></a><!-- doxytag: member="theora.h::theora_version_number" ref="d9cec696a9c830e9b3cb1bf4e372b23d" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ogg_uint32_t theora_version_number           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve a 32-bit version number. 
<p>
This number is composed of a 16-bit major version, 8-bit minor version and 8 bit sub-version, composed as follows: <pre>
   (VERSION_MAJOR&lt;&lt;16) + (VERSION_MINOR&lt;&lt;8) + (VERSION_SUB)
</pre> <dl compact><dt><b>Returns:</b></dt><dd>The version number. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7682deb3e6612db562f54ea66b95584b"></a><!-- doxytag: member="theora.h::theora_version_string" ref="7682deb3e6612db562f54ea66b95584b" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const char* theora_version_string           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve a human-readable string to identify the encoder vendor and version. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A version string. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jun 20 13:16:23 2006 for libtheora by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
